<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to qtlpvl}
-->

```{r, echo = FALSE, message = FALSE}
library(qtlpvl)
knitr::opts_chunk$set(
    fig.width=10, fig.height=6,
    comment = "#>",
    error = FALSE,
    tidy = FALSE)
```

# Introduction to qtlpvl

This package is focusing on QTL mapping with multiple traits and
testing of pleiotrophy vs. close linkage when multiple traits mapped
near each other, with the case of trans-eQTL hotspot in mind
particularly. We provide both exploration plot functions and formal
statistical tests aimning at dissecting trans-eQTL hotspots.

## Data

We used data `listeria` from `R\qtl` as an example. We used the
genotypes of this F$_2$ population and simulated the phenotypes from
normal distribution. First we picked two markers from chromosome 1 as QTL,
assuming the first QTL have additive effect only and the second QTL have
dominant effect --individuals with genotype 2 and 3 are grouped
together to have the same shift in mean. Then we assumed the first 5
traits to be controlled by the first QTL and the other 5 trait of the
total 10 to be controlled by the second QTL with negative, bigger
effect. The 10 phenotypes were generated with these QTL effects plus
independent noise generated from standard normal distribution. Assume
that these traits are measurements of gene expressions and we randomly
assigned positions for these genes. The phenotype data is stored
in matrix `Y` and their positions are stored in data.frame `probepos`,
both are saved in the package and we can load them by:

```{r}
data(fake.phenos)
```

We will first look at the single triat analysis result. For each
trait, we plot its LOD score versus QTL position when the LOD is
bigger than a threshold (default value is 3). To do so we first
calculate the genotype probabilities for `listeria` and then use
function `plotLOD`.

```{r,plotLOD,fig.cap="LOD score and QTL positions for each of the simulated traits"}
data(listeria)
listeria <- calc.genoprob(listeria, step=1)
chr <- 1
plotLOD(Y=Y, cross=listeria, chr=chr)
```

## joint mapping: `scanone.mvn`

Having the cross object `listeria` and phenotype trait matrix `Y`
loaded, we can run a joint mapping with `scanone.mvn`, which
assumes multivariate normal model. `chr` is set to be "1", which
indicates the mapping is only on chromosome 1. Function `scanone.mvn`
has two more parameters `addcovar` and `intcovar`, they could be used
to control for additive and interactive covariates when
needed. `intcovar` will also be used as additive covariates during
mapping, and there is no need to manually add them into `addcovar` by
the user.

The result of joint mapping is a data frame with class `scanone`, we
could apply (S3) method `summary` and `plot` to look at the result.

```{r,scanonemvn, fig.cap="Joint mapping result under multivariate normal model for all the simulated triats"}
out <- scanone.mvn(cross=listeria, Y=Y, chr=chr)
summary(out)
plot(out)
```

We could see the QTL is at `r sprintf("%.2f",summary(out)$pos)` cM
with LOD score `r sprintf("%.2f",summary(out)$lod)`. It is more
towards the second QTL since the second QTL has a bigger effect than
the first in our simulation.

## Statistical Testing
### test of 1 vs 2 QTL: `testpleio.1vs2`

We test the hypothesis of:
* $H_0$: There is only one QTL affecting all the phenotypes;
* $H_1$: There are two QTLs, each affecting one of the two phenotype
  groups.

We assume the traits follow multivariate normal distribution and
perform joint mapping to locate the single-QTL under the null
hypothesis that there is one pleiotrophic QTL affecting all the
traits; we then run single trait analysis on each trait and find the
trait-specific QTL, sort the traits by their QTL position and search
for the best separation of the traits into two groups, where the first
group (contains the first several traits) is controlled by the right
QTL and the second group (contains the rest traits) is controlled by
the left QTL. The LOD score of this two-QTL model is then subtracted
by the LOD score of the single-QTL model to arrived at the final test
statistic, $\text{LOD}_{2v1}$.

To get the null distribution of the statistics, we have two methods:
* parametric bootstrap: generate data from the parameters estimated
  under the null hypothesis
* stratified permutation: randomly permute the genotype data versus
  phenotype data with in each QTL genotype group,

we repeat the whole procedure on data from either method and save the
test statistics. The P-value is calculated from this empirical
distribution.

Function `testpleio.1vs2` is used to do this test. Input parameters:
* cross: An object of class `cross`.
* Y: matrix of multiple traits, with samples in the row, traits in the
  column.
* chr: One character strings referring to chromosome of interest by
  name.
* region.l, region.r: left and right bound for the interval of
  interest.
* int.method: can have value of `bayes` or `1.5lod`, method to
  calculated the interval of interest if `region.l` and `region.r` is
  not specified.
* search.method: searching method for two-QTL model, can have value of
  `fast` or `complete`, default is `fast`.
* RandomStart: when search.method is `fast`, use random starting point
  for the two-QTL model or not, default is `TRUE`.
* RandomCut: use random cutting or not when there are traits mapped to
  the same location. default is `FALSE`, triats mapped to the same
  location will be bound together.
* simu.method: `parametric` or `permutation` method for
  simulations. default is `parametric`.
* n.simu: number of simulations for p-value.
* tol: Tolerance value for the `qr` decomposition in `lm` fitting.
* addcovar, intcovar: Additive and interactive covariates to control
  for when mapping.

This function will return a list with class `testpleio.1vs2`, similar
to `scanone`, we could apply (S3) method `summary` and `plot` to look
at the result. In the summary, we could see the position and LOD score
for the single QTL and best two QTL model, as well as test statistics
$\text{LOD}_{2v1}$ and its P-value.

```{r, fig.cap="LOD profile plot for result of test1vs2 on simulated traits"}
obj <- testpleio.1vs2(cross=listeria, Y=Y, chr=chr, n.simu=10,
                      region.l=60, region.r=90,
                      search.method="complete")
summary(obj)
plot(obj)
```

The above figure shows the joint mapping result in black and profile
for each of the two QTLs under $H_1$:

* red line: $L_1(\lambda_1) = \max_{\lambda_2} LOD2(\lambda_1,
  \lambda_2)$
* blue line: $L_2(\lambda_2) = \max_{\lambda_1} LOD2(\lambda_1,
  \lambda_2)$

Triangles indicate the position of the QTLs and solid points indicate
QTL positions and LODs from single trait mapping.

```{r, fig.cap="plot of LOD$_{2v1}$ by cut-point"}
plottrace(obj)
```

We use `plottrace` to see how $\text{LOD}_{2v1}$ changes
when we move the cut-point of the left versus right group. There are 7
possible QTL positions from the above plot (result of single trait
mapping), thus we have 6 possible ways of grouping these positions
into the left versus right group. The 6 dot indict the cut and
their $\text{LOD}_{2v1}$. Thus when the first 5 traits and the last 5
traits are grouped separately, the $\text{LOD}_{2v1}$ is the biggest,
it is our best two QTL model. This figure could be used as a
diagnostic figure, to see if our best two QTL model is better than the
rest of all the possible models.


### test of 1 vs p QTL: `testpleio.1vsp`

We could also test the hypothesis of:
* $H_0$: There is only one QTL affecting all the phenotypes;
* $H_1$: There are p QTLs, each affecting one of the phenotypes, i.e.,
  each phenotype is allowed to has its own QTL.

This function has much less parameters than the previous one. We have
`cross`, `Y`, `chr`, `addcovar`, `intcovar` and `n.simu`, the usage is
same as before.  This function will return a list with class
`testpleio.1vsp`, similar to `scanone` and `testpleio.1vs2`, we could
apply (S3) method `summary` and `plot` to look at the result. In the
summary, we could see the position and LOD score for the single QTL
and p QTL model, as well as test statistics $\text{LOD}_{2v1}$ and its
P-value.

```{r, fig.cap="plot for result of testpleio.1vsp, showing joing mapping LOD curve and max LOD score for each trait seperately"}
obj2 <- testpleio.1vsp(cross=listeria, Y=Y, chr=chr, n.simu=10)
summary(obj2)
plot(obj2)
```

## Exploration plots

### plot Genetic Pattern: `plotGenetpattern`

Function `plotGenetpattern` takes two kinds of input parameters:
* a phenotype matrix `Y` and a genotype vector `genotype`, the later
  should be genotype of the common QTL in most suspicious.
* a phenotype matrix `Y` and a cross object `cross` and chromosome
  number `chr`. This is used when there is no certainty of a single
  QTL for all traits and thus each trait is mapped separately and its
  own QTL genotype is used.

QTL additive effect is defined as a=(RR-BB)/2, QTL dominant effect is
defined as d=BR-(BB+RR)/2, when plotted against each other, traits
with pure additive effects are near the x-axis ($d=0$) and traits with
dominant effects are along the diagonals, $d=a$ (BR=RR) and $d=-a$
(BR=BB).

```{r, fig.width=12, fig.height=6, fig.cap="plot of inheritance pattern for all the simulated traits"}
par(mfrow=c(1,2))
qtlpos <- max(out)$pos
m <- find.pseudomarker(listeria, chr, qtlpos, "prob", addchr=FALSE)
qtlgeno <- apply(listeria$geno[[chr]]$prob[,m,], 1, which.max)

plotGenetpattern(Y=Y, genotype=qtlgeno, main="by common QTL genotype")
plotGenetpattern(Y=Y, cross=listeria, chr=chr,
                 main="by individual QTL genotype")
```

We can tell from both plots the there are two different genetic
patterns, thus possible two different QTLs, even if they are closely
linked.

### plot LOD score with sign: `plotLODsign`

Using the same data, we could also display the direction of the QTL
effect with `plotLODsign`.  Function `plotLODsign` takes input
`cross`, `Y` and `chr`, as well as `addcovar` and `intcovar`, all has
been introduced above.

For each trait, the QTL effect direction is used as the sign of the
LOD score. We first run single trait mapping for LOD scores and QTL
positions, then we use `argmax.geno` to impute QTL genotypes and
calculate mean for each of the 3 genotype group. We define the
direction positive when the mean of the first group is bigger than the
mean of the third group, and negative if not. Only traits with LOD
score bigger than a threshold will be displayed, the default value of
the threshold `LOD.threshold` is set as 3.

```{r,fig.cap="plot of signed LOD score for all the simulated triats"}
plotLODsign(Y=Y, cross=listeria, chr=chr)
```

We indicate the positions of all the genotyped markers with little
ticks at the x-axis. We can pass these values to parameter `map` or
let the function handle it by pulling this information from the
`cross` object at a fixed `chr`.

If we already have mapped the traits (which, in most cases, is done in
previouse steps), we can simply pass the signed LOD scores and their
mapped positions to `LODsign` and `maxPOS` respectively, to speed up
the procedure by skiping mapping the triats redundantly. The use of
this feature will be shown at the last section.

### Linear discriminant plot: `plottrans.LDA`

In this method we group individuals into two groups by whether there
is a recombiantion event in the region. For individuals with no
recombinantion events, we will know there eQTL genotype since they
have the same genotype in the region, we then apply linear
discriminant analysis to the traits with the eQTL genotype as `label`
and plot the first two linear discriminants, shown as three distince
clusters. We then calculate the linear discriminants for the other
group with recombinantion event in the region by using the same
coffecients, and add them to the plot. If the recombinant individuals
fall within the clusters defined by the non-recombinants, this is
consistent with there being a single eQTL. If, on the other hand, the
recombinants look distinctly different from the non-recombinants, then
there might be more than one eQTL.

In the following code, we first find which inidviduals have no
recombinant event, and then call the function `plottrans.LDA` with
phenotype matrix `Y`, QTL genotype `qtlgeno` and nonrecombinant IDs
`nonrecomb`.

```{r, fig.cap="LDA plot for the simulated triats, non-recombinant mice are colored as yellow"}
out <- out[out$chr==chr, ]
m <- which(out$pos >= qtlpos-5 & out$pos <= qtlpos+5)
g <- apply(listeria$geno[[chr]]$prob[,m,], 1:2, which.max)
nonrecomb <- which(sapply(apply(g, 1, unique), length) == 1)
names(nonrecomb) <- rownames(Y)[nonrecomb]
plottrans.LDA(Y, qtlgeno, nonrecomb)
```

In the above plot each point is a individual colored by its QTL
genotype if it is non-recombinant, or yellow if it has recombiant.

## Analysis as trans-eQTL hotspot with probepos

Lastely, we will show the whole procedure recommended for analysis of
expression data. We start by mapping each phenotype individually,
then count the number of eQTLs in windows of 10~cM, when there seems
to be a trans-eQTL hotspot, we can build a object `transband` by
`make.transbands`, the object contains basic information of the
transband: chromosome and postion of the transband, number of eQTLs in
the transband, and estimate of QTL position and LOD score under
multivariate assumption; it also contians all the information needed
for the exploration plots: QTL LOD scores and positions, additive and
dominance effects, QTL geneotypes, and non-recombinant IDs. It is
easier to extract these infomations from this object and run all the
statistical test and exploration plots in a batch.

```{r, all, fig.width=12, fig.height=8, fig.cap="Summary plot for a trans-eQTL hotspot using simulated data"}
phenoname <- colnames(Y)
listeria$pheno <- data.frame(listeria$pheno, Y)
out <- scanone(listeria, pheno.col=phenoname, chr=1:19)
out1 <- convert_scan1(out, phenoname, chr=1:19)

marker.info <- get.marker.info(listeria, chr)
out.count <- count.trans(out1, probepos, chr, marker.info)

par(mfrow=c(2,3))
plot(out.count, main="Count of trans-eQTL")

trans <- make.transbands(out1, probepos, cross=listeria, chr=1:19,
                         mlratio = Y, lod.thr = 5,
                         trans.cM = 5, kernal.width = 1,
                         window.cM = 10, trans.count.thr = 0,
                         regn.cM = 5)
transband <- trans[[1]]

geno <- attr(transband, "geno")
nonrecomb <- attr(transband, "nonrecomb")
out <- attr(transband, "out")
map <- pull.map(listeria)

plot(obj, main="LOD profile")
plottrace(obj, main="Trace")
plotLODsign(maxPOS=out$pos, LODsign=sign(out$eff.a)*out$lod1, map=map[[chr]],
            main="Signed LOD")
plotGenetpattern(a=out$eff.a, d=out$eff.d, main="Inheritance Pattern")
plottrans.LDA(Y, geno, nonrecomb, main="LDA plot")

```


## Session Info
```{r}
sessionInfo()
```
